import 'dart:io';
import 'dart:typed_data';

import 'package:flutter_test/flutter_test.dart';
import 'package:flutter_litert/flutter_litert.dart';

// Model generated by scripts/generate_training_model.py
// Architecture: linear regression y = wx + b, w=0 b=0 initially, SGD lr=0.01
//
// Signatures:
//   train:       inputs={x:[1,1], y:[1,1]}  outputs={loss:[1]}
//   infer:       inputs={x:[1,1]}           outputs={output:[1,1]}
//   get_weights: no inputs                  outputs={w:[1,1], b:[1]}
//   set_weights: inputs={w:[1,1], b:[1]}    outputs={w:[1,1], b:[1]}
File get _modelFile =>
    File('${Directory.current.path}/test/assets/training_model.tflite');

void main() {
  late Interpreter interpreter;

  setUp(() {
    interpreter = Interpreter.fromFile(_modelFile);
  });

  tearDown(() {
    if (!interpreter.isDeleted) interpreter.close();
  });

  // ─── Group 1: Interpreter-level signature introspection ──────────────────

  group('Interpreter signature introspection', () {
    test('signatureCount is 4', () {
      expect(interpreter.signatureCount, equals(4));
    });

    test('signatureKeys contains all four signatures', () {
      expect(
        interpreter.signatureKeys,
        containsAll(['train', 'infer', 'get_weights', 'set_weights']),
      );
    });

    test('getSignatureKey by index returns a non-empty string', () {
      for (int i = 0; i < interpreter.signatureCount; i++) {
        expect(interpreter.getSignatureKey(i), isNotEmpty);
      }
    });

    test('getSignatureRunner throws ArgumentError for unknown key', () {
      expect(
        () => interpreter.getSignatureRunner('does_not_exist'),
        throwsA(isA<ArgumentError>()),
      );
    });
  });

  // ─── Group 2: Construction and tensor introspection ──────────────────────

  group('SignatureRunner construction and introspection', () {
    late SignatureRunner inferRunner;

    setUp(() => inferRunner = interpreter.getSignatureRunner('infer'));
    tearDown(() {
      if (!inferRunner.isClosed) inferRunner.close();
    });

    test('isClosed is false after construction', () {
      expect(inferRunner.isClosed, isFalse);
    });

    test('toString contains inputs/outputs when open', () {
      final s = inferRunner.toString();
      expect(s, contains('inputs:'));
      expect(s, contains('outputs:'));
      expect(s, contains('closed: false'));
    });

    test('inputCount for infer is 1', () {
      expect(inferRunner.inputCount, equals(1));
    });

    test('outputCount for infer is 1', () {
      expect(inferRunner.outputCount, equals(1));
    });

    test('inputNames for infer contains x', () {
      expect(inferRunner.inputNames, contains('x'));
    });

    test('outputNames for infer contains output', () {
      expect(inferRunner.outputNames, contains('output'));
    });

    test('getInputName(0) returns x', () {
      expect(inferRunner.getInputName(0), equals('x'));
    });

    test('getOutputName(0) returns output', () {
      expect(inferRunner.getOutputName(0), equals('output'));
    });

    test('getInputTensor returns tensor with correct shape and type', () {
      final tensor = inferRunner.getInputTensor('x');
      expect(tensor.shape, equals([1, 1]));
      expect(tensor.type, equals(TensorType.float32));
    });

    test('getInputTensors() length equals inputCount', () {
      expect(
        inferRunner.getInputTensors().length,
        equals(inferRunner.inputCount),
      );
    });

    test('getOutputTensors() length equals outputCount', () {
      inferRunner.allocateTensors();
      expect(
        inferRunner.getOutputTensors().length,
        equals(inferRunner.outputCount),
      );
    });

    test('getInputTensor throws ArgumentError for invalid name', () {
      expect(
        () => inferRunner.getInputTensor('nonexistent'),
        throwsA(isA<ArgumentError>()),
      );
    });

    test('getOutputTensor throws ArgumentError for invalid name', () {
      expect(
        () => inferRunner.getOutputTensor('nonexistent'),
        throwsA(isA<ArgumentError>()),
      );
    });
  });

  // ─── Group 3: allocateTensors ─────────────────────────────────────────────

  group('allocateTensors', () {
    late SignatureRunner inferRunner;

    setUp(() => inferRunner = interpreter.getSignatureRunner('infer'));
    tearDown(() {
      if (!inferRunner.isClosed) inferRunner.close();
    });

    test('succeeds without throwing', () {
      expect(() => inferRunner.allocateTensors(), returnsNormally);
    });

    test('can be called multiple times without error', () {
      inferRunner.allocateTensors();
      expect(() => inferRunner.allocateTensors(), returnsNormally);
    });

    test('resize then allocate works', () {
      inferRunner.resizeInputTensor('x', [1, 1]);
      expect(() => inferRunner.allocateTensors(), returnsNormally);
    });

    test('throws StateError after close', () {
      inferRunner.close();
      expect(() => inferRunner.allocateTensors(), throwsA(isA<StateError>()));
    });
  });

  // ─── Group 4: invoke ─────────────────────────────────────────────────────

  group('invoke', () {
    late SignatureRunner inferRunner;

    setUp(() => inferRunner = interpreter.getSignatureRunner('infer'));
    tearDown(() {
      if (!inferRunner.isClosed) inferRunner.close();
    });

    test('throws StateError without prior allocateTensors', () {
      expect(() => inferRunner.invoke(), throwsA(isA<StateError>()));
    });

    test('succeeds after allocateTensors', () {
      inferRunner.allocateTensors();
      expect(() => inferRunner.invoke(), returnsNormally);
    });

    test('throws StateError after close', () {
      inferRunner.allocateTensors();
      inferRunner.close();
      expect(() => inferRunner.invoke(), throwsA(isA<StateError>()));
    });
  });

  // ─── Group 5: run — infer ────────────────────────────────────────────────

  group('run — infer signature', () {
    late SignatureRunner inferRunner;

    setUp(() => inferRunner = interpreter.getSignatureRunner('infer'));
    tearDown(() {
      if (!inferRunner.isClosed) inferRunner.close();
    });

    // infer output tensor has shape [1,1] — use a nested list to match.
    List<List<double>> inferOutput() => [
      [0.0],
    ];

    test('produces a finite float32 output', () {
      final output = inferOutput();
      inferRunner.run(
        {
          'x': [
            [1.0],
          ],
        },
        {'output': output},
      );
      expect(output[0][0].isFinite, isTrue);
    });

    test('untrained model predicts 0 for any input (w=0, b=0)', () {
      final output = inferOutput();
      inferRunner.run(
        {
          'x': [
            [5.0],
          ],
        },
        {'output': output},
      );
      expect(output[0][0], closeTo(0.0, 1e-5));
    });

    test('can be called multiple times', () {
      for (int i = 0; i < 5; i++) {
        final output = inferOutput();
        expect(
          () => inferRunner.run(
            {
              'x': [
                [(i * 1.0)],
              ],
            },
            {'output': output},
          ),
          returnsNormally,
        );
      }
    });

    test(
      'lastNativeInferenceDurationMicroSeconds is non-negative after run',
      () {
        final output = inferOutput();
        inferRunner.run(
          {
            'x': [
              [1.0],
            ],
          },
          {'output': output},
        );
        expect(
          inferRunner.lastNativeInferenceDurationMicroSeconds,
          greaterThanOrEqualTo(0),
        );
      },
    );

    test('throws StateError on closed runner', () {
      inferRunner.close();
      expect(
        () => inferRunner.run(
          {
            'x': [
              [1.0],
            ],
          },
          {'output': inferOutput()},
        ),
        throwsA(isA<StateError>()),
      );
    });
  });

  // ─── Group 6: run — train ────────────────────────────────────────────────

  group('run — train signature', () {
    late SignatureRunner trainRunner;

    setUp(() => trainRunner = interpreter.getSignatureRunner('train'));
    tearDown(() {
      if (!trainRunner.isClosed) trainRunner.close();
    });

    test('inputNames contains x and y', () {
      expect(trainRunner.inputNames, containsAll(['x', 'y']));
    });

    test('outputNames contains loss', () {
      expect(trainRunner.outputNames, contains('loss'));
    });

    test('first training step returns a finite loss', () {
      final loss = Float32List(1);
      trainRunner.run(
        {
          'x': [
            [1.0],
          ],
          'y': [
            [2.0],
          ],
        },
        {'loss': loss},
      );
      expect(loss[0].isFinite, isTrue);
    });

    test('first loss for (x=1, y=2) is 4.0  — pred=0, MSE=(0-2)^2=4', () {
      final loss = Float32List(1);
      trainRunner.run(
        {
          'x': [
            [1.0],
          ],
          'y': [
            [2.0],
          ],
        },
        {'loss': loss},
      );
      expect(loss[0], closeTo(4.0, 0.01));
    });

    test('loss decreases over 20 training steps', () {
      final loss = Float32List(1);
      double firstLoss = 0;
      double lastLoss = 0;
      for (int i = 0; i < 20; i++) {
        trainRunner.run(
          {
            'x': [
              [1.0],
            ],
            'y': [
              [2.0],
            ],
          },
          {'loss': loss},
        );
        if (i == 0) firstLoss = loss[0];
        lastLoss = loss[0];
      }
      expect(lastLoss, lessThan(firstLoss));
    });

    test(
      'weight updates are visible via infer runner on the same interpreter',
      () {
        // Train and infer runners share underlying interpreter memory —
        // weight updates made through train are immediately visible to infer.
        final loss = Float32List(1);
        for (int i = 0; i < 50; i++) {
          trainRunner.run(
            {
              'x': [
                [1.0],
              ],
              'y': [
                [2.0],
              ],
            },
            {'loss': loss},
          );
        }
        trainRunner.close();

        final inferRunner = interpreter.getSignatureRunner('infer');
        final output = [
          [0.0],
        ]; // shape [1,1] to match infer output tensor
        inferRunner.run(
          {
            'x': [
              [1.0],
            ],
          },
          {'output': output},
        );
        inferRunner.close();

        // After 50 steps at lr=0.01 the model converges toward 2.0.
        // Asserting >0.5 is conservative enough to be stable across platforms.
        expect(output[0][0], greaterThan(0.5));
      },
    );

    test('throws StateError on closed runner', () {
      trainRunner.close();
      expect(
        () => trainRunner.run(
          {
            'x': [
              [1.0],
            ],
            'y': [
              [2.0],
            ],
          },
          {'loss': Float32List(1)},
        ),
        throwsA(isA<StateError>()),
      );
    });
  });

  // ─── Group 7: run — get_weights ──────────────────────────────────────────

  group('run — get_weights signature', () {
    late SignatureRunner getWeightsRunner;

    setUp(
      () => getWeightsRunner = interpreter.getSignatureRunner('get_weights'),
    );
    tearDown(() {
      if (!getWeightsRunner.isClosed) getWeightsRunner.close();
    });

    test('has no inputs and outputs w and b', () {
      expect(getWeightsRunner.inputCount, equals(0));
      expect(getWeightsRunner.outputNames, containsAll(['w', 'b']));
    });

    test('returns initial weights w=0, b=0', () {
      final w = [
        [0.0],
      ];
      final b = [0.0];
      getWeightsRunner.run({}, {'w': w, 'b': b});
      expect(w[0][0], closeTo(0.0, 1e-5));
      expect(b[0], closeTo(0.0, 1e-5));
    });

    test('reflects trained weights after training steps', () {
      // Train for 20 steps first
      final trainRunner = interpreter.getSignatureRunner('train');
      final loss = Float32List(1);
      for (int i = 0; i < 20; i++) {
        trainRunner.run(
          {
            'x': [
              [1.0],
            ],
            'y': [
              [2.0],
            ],
          },
          {'loss': loss},
        );
      }
      trainRunner.close();

      // get_weights should now return non-zero values
      final w = [
        [0.0],
      ];
      final b = [0.0];
      getWeightsRunner.run({}, {'w': w, 'b': b});
      expect(w[0][0], isNot(closeTo(0.0, 1e-5)));
    });

    test('throws StateError on closed runner', () {
      getWeightsRunner.close();
      expect(
        () => getWeightsRunner.run({}, {
          'w': [
            [0.0],
          ],
          'b': [0.0],
        }),
        throwsA(isA<StateError>()),
      );
    });
  });

  // ─── Group 8: run — set_weights ──────────────────────────────────────────

  group('run — set_weights signature', () {
    late SignatureRunner setWeightsRunner;

    setUp(
      () => setWeightsRunner = interpreter.getSignatureRunner('set_weights'),
    );
    tearDown(() {
      if (!setWeightsRunner.isClosed) setWeightsRunner.close();
    });

    test('inputNames contains w and b', () {
      expect(setWeightsRunner.inputNames, containsAll(['w', 'b']));
    });

    test('set_weights then infer produces expected prediction', () {
      // Set weights to known values: w=3.0, b=1.0 → infer(x=2) = 3*2+1 = 7
      setWeightsRunner.run({
        'w': [
          [3.0],
        ],
        'b': [1.0],
      }, {});
      setWeightsRunner.close();

      final inferRunner = interpreter.getSignatureRunner('infer');
      final output = [
        [0.0],
      ];
      inferRunner.run(
        {
          'x': [
            [2.0],
          ],
        },
        {'output': output},
      );
      inferRunner.close();

      expect(output[0][0], closeTo(7.0, 0.01));
    });

    test('throws StateError on closed runner', () {
      setWeightsRunner.close();
      expect(
        () => setWeightsRunner.run({
          'w': [
            [1.0],
          ],
          'b': [0.0],
        }, {}),
        throwsA(isA<StateError>()),
      );
    });
  });

  // ─── Group 8b: full persistence round-trip ──────────────────────────────

  group(
    'full persistence round-trip (train → get → new interpreter → set → infer)',
    () {
      test('trained weights survive interpreter recreation via get/set', () {
        // 1. Train on original interpreter
        final trainRunner = interpreter.getSignatureRunner('train');
        final loss = Float32List(1);
        for (int i = 0; i < 50; i++) {
          trainRunner.run(
            {
              'x': [
                [1.0],
              ],
              'y': [
                [2.0],
              ],
            },
            {'loss': loss},
          );
        }
        trainRunner.close();

        // 2. Extract trained weights
        final getRunner = interpreter.getSignatureRunner('get_weights');
        final w = [
          [0.0],
        ];
        final b = [0.0];
        getRunner.run({}, {'w': w, 'b': b});
        getRunner.close();

        // 3. Record prediction from trained interpreter
        final inferA = interpreter.getSignatureRunner('infer');
        final predA = [
          [0.0],
        ];
        inferA.run(
          {
            'x': [
              [1.0],
            ],
          },
          {'output': predA},
        );
        inferA.close();

        // 4. Close original interpreter, create a fresh one (weights reset to 0)
        interpreter.close();
        interpreter = Interpreter.fromFile(_modelFile);

        // 5. Verify fresh interpreter predicts 0 (untrained)
        final inferFresh = interpreter.getSignatureRunner('infer');
        final predFresh = [
          [0.0],
        ];
        inferFresh.run(
          {
            'x': [
              [1.0],
            ],
          },
          {'output': predFresh},
        );
        inferFresh.close();
        expect(predFresh[0][0], closeTo(0.0, 1e-5));

        // 6. Restore weights into fresh interpreter
        final setRunner = interpreter.getSignatureRunner('set_weights');
        setRunner.run({'w': w, 'b': b}, {});
        setRunner.close();

        // 7. Infer again — should match the trained prediction
        final inferB = interpreter.getSignatureRunner('infer');
        final predB = [
          [0.0],
        ];
        inferB.run(
          {
            'x': [
              [1.0],
            ],
          },
          {'output': predB},
        );
        inferB.close();

        // Predictions from trained interpreter A and restored interpreter B must match
        expect(predB[0][0], closeTo(predA[0][0], 1e-5));
        // And both should be close to the target (2.0)
        expect(predB[0][0], greaterThan(0.5));
      });
    },
  );

  // ─── Group 9: cancel ─────────────────────────────────────────────────────

  group('cancel', () {
    late SignatureRunner inferRunner;

    setUp(() => inferRunner = interpreter.getSignatureRunner('infer'));
    tearDown(() {
      if (!inferRunner.isClosed) inferRunner.close();
    });

    test('does not throw outside an active invocation', () {
      expect(() => inferRunner.cancel(), returnsNormally);
    });

    test('returns a bool', () {
      expect(inferRunner.cancel(), isA<bool>());
    });

    test('runner remains usable after cancel', () {
      inferRunner.cancel();
      final output = [
        [0.0],
      ]; // shape [1,1]
      expect(
        () => inferRunner.run(
          {
            'x': [
              [1.0],
            ],
          },
          {'output': output},
        ),
        returnsNormally,
      );
    });

    test('throws StateError after close', () {
      inferRunner.close();
      expect(() => inferRunner.cancel(), throwsA(isA<StateError>()));
    });
  });

  // ─── Group 10: close lifecycle ───────────────────────────────────────────

  group('close lifecycle', () {
    test('isClosed is true after close', () {
      final runner = interpreter.getSignatureRunner('infer');
      runner.close();
      expect(runner.isClosed, isTrue);
    });

    test('double close throws StateError', () {
      final runner = interpreter.getSignatureRunner('infer');
      runner.close();
      expect(() => runner.close(), throwsA(isA<StateError>()));
    });

    test('toString reflects closed state', () {
      final runner = interpreter.getSignatureRunner('infer');
      runner.close();
      expect(runner.toString(), contains('closed: true'));
      // Must not crash by calling native functions on freed pointer.
      expect(runner.toString(), isA<String>());
    });

    test('all four runners can be created and closed independently', () {
      final r1 = interpreter.getSignatureRunner('train');
      final r2 = interpreter.getSignatureRunner('infer');
      final r3 = interpreter.getSignatureRunner('get_weights');
      final r4 = interpreter.getSignatureRunner('set_weights');
      expect(() {
        r1.close();
        r2.close();
        r3.close();
        r4.close();
      }, returnsNormally);
    });
  });
}
